<!DOCTYPE html>
<html lang="zh-CN" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç­”é¢˜ç³»ç»Ÿ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Microsoft YaHei', Arial, sans-serif; background-color: #f5f5f5; height: 100vh; overflow: hidden; }
        .quiz-container { display: flex; height: 100vh; }
        .sidebar { width: 15%; background-color: #2c3e50; color: white; overflow-y: auto; padding: 20px 0; }
        .sidebar h3 { padding: 0 20px 15px; border-bottom: 1px solid #34495e; margin-bottom: 15px; color: #ecf0f1; }
        .chapter { margin-bottom: 10px; }
        .chapter-title { padding: 10px 20px; background-color: #34495e; cursor: pointer; font-weight: bold; transition: background-color 0.3s; }
        .chapter-title:hover { background-color: #4a5f7a; }
        .chapter-title.active { background-color: #3498db; }
        .questions-list { display: none; background-color: #34495e; }
        .questions-list.show { display: block; }
        .question-item { padding: 8px 20px 8px 40px; cursor: pointer; transition: background-color 0.3s; border-left: 3px solid transparent; }
        .question-item:hover { background-color: #4a5f7a; }
        .question-item.active { background-color: #3498db; border-left-color: #ecf0f1; }
        .question-item.answered { color: #2ecc71; }
        .main-content { width: 85%; display: flex; flex-direction: column; }
        .question-section { height: 20%; background-color: white; padding: 20px; border-bottom: 2px solid #e0e0e0; overflow-y: auto; }
        .question-title { font-size: 1.5em; color: #2c3e50; margin-bottom: 10px; font-weight: bold; }
        .question-description { color: #555; line-height: 1.6; font-size: 1.1em; }
        .no-question { text-align: center; color: #999; font-size: 1.2em; margin-top: 50px; }
        .answer-section { height: 80%; background-color: white; padding: 20px; display: flex; flex-direction: column; }
        .answer-title { font-size: 1.3em; color: #2c3e50; margin-bottom: 15px; font-weight: bold; }
        .answer-editor { flex: 1; border: 2px solid #ddd; border-radius: 8px; padding: 15px; font-size: 16px; line-height: 1.6; outline: none; overflow-y: auto; background-color: #fafafa; transition: border-color 0.3s; }
        .answer-editor:focus { border-color: #3498db; background-color: white; }
        .save-status { margin-top: 10px; padding: 8px 12px; border-radius: 4px; font-size: 14px; display: none; }
        .save-status.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .save-status.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .save-status.saving { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .toolbar { display: flex; gap: 10px; margin-bottom: 15px; }
        .toolbar button { padding: 8px 16px; border: 1px solid #ddd; background-color: white; border-radius: 4px; cursor: pointer; transition: all 0.3s; }
        .toolbar button:hover { background-color: #f8f9fa; border-color: #3498db; }
        .toolbar button.active { background-color: #3498db; color: white; border-color: #3498db; }
        @media (max-width: 768px) { .sidebar { width: 25%; } .main-content { width: 75%; } .question-section { height: 25%; } .answer-section { height: 75%; } }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="sidebar">
            <h3>ğŸ“š é¢˜ç›®ç›®å½•</h3>
            <div th:each="chapter : ${chapters}" class="chapter">
                <div class="chapter-title" th:onclick="toggleChapter(this)" th:text="${chapter.title}">ç« èŠ‚æ ‡é¢˜</div>
                <div class="questions-list" th:id="'questions-' + ${chapter.id}">
                    <div th:each="question : ${chapter.questions}" class="question-item" th:data-question-id="${question.id}" th:data-question-title="${question.title}" th:onclick="selectQuestion(this)" th:text="${question.questionNumber + '. ' + question.title}">é¢˜ç›®</div>
                </div>
            </div>
        </div>
        <div class="main-content">
            <div class="question-section">
                <div id="question-content">
                    <div class="no-question">è¯·ä»å·¦ä¾§é€‰æ‹©é¢˜ç›®å¼€å§‹ç­”é¢˜</div>
                </div>
            </div>
            <div class="answer-section">
                <div class="answer-title">ğŸ’­ æˆ‘çš„ç­”æ¡ˆ</div>
                <div class="toolbar">
                    <button onclick="formatText('bold')" title="ç²—ä½“">B</button>
                    <button onclick="formatText('italic')" title="æ–œä½“">I</button>
                    <button onclick="formatText('underline')" title="ä¸‹åˆ’çº¿">U</button>
                    <button onclick="insertImage()" title="æ’å…¥å›¾ç‰‡">ğŸ“·</button>
                    <button onclick="clearFormat()" title="æ¸…é™¤æ ¼å¼">æ¸…é™¤æ ¼å¼</button>
                    <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
                </div>
                <div id="answer-editor" class="answer-editor" contenteditable="true" data-placeholder="è¯·åœ¨æ­¤è¾“å…¥æ‚¨çš„ç­”æ¡ˆ..."></div>
                <div id="save-status" class="save-status"></div>
            </div>
        </div>
    </div>

    <script>
        let currentQuestionId = null;
        let currentQuestionTitle = null;
        let currentUsername = '[[${username}]]';
        let saveTimeout = null;

        function toggleChapter(element) {
            const chapterId = element.nextElementSibling.id.split('-')[1];
            const questionsList = document.getElementById('questions-' + chapterId);
            questionsList.classList.toggle('show');
            document.querySelectorAll('.chapter-title').forEach(title => { title.classList.remove('active'); });
            element.classList.add('active');
        }

        function selectQuestion(element) {
            const questionId = element.dataset.questionId;
            const questionTitle = element.dataset.questionTitle;
            document.querySelectorAll('.question-item').forEach(item => { item.classList.remove('active'); });
            element.classList.add('active');
            loadQuestion(questionId, questionTitle);
            loadAnswer(questionId, questionTitle);
        }

        function loadQuestion(questionId, questionTitle) {
            currentQuestionId = questionId;
            currentQuestionTitle = questionTitle;
            fetch(`/quiz/question/${questionId}?username=${currentUsername}`)
                .then(response => response.json())
                .then(question => {
                    const questionContent = document.getElementById('question-content');
                    questionContent.innerHTML = `
                        <div class="question-title">${question.questionNumber}. ${question.title}</div>
                        <div class="question-description">${question.description}</div>
                    `;
                })
                .catch(error => { console.error('åŠ è½½é¢˜ç›®å¤±è´¥:', error); });
        }

        function loadAnswer(questionId, questionTitle) {
            let url = '';
            if (questionTitle) {
                url = `/quiz/answer?title=${encodeURIComponent(questionTitle)}&username=${currentUsername}`;
            } else {
                url = `/quiz/answer/${questionId}?username=${currentUsername}`;
            }
            
            fetch(url)
                .then(response => { if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response.json(); })
                .then(answer => {
                    const editor = document.getElementById('answer-editor');
                    if (answer.content && answer.content.trim()) {
                        editor.innerHTML = answer.content;
                    } else {
                        editor.innerHTML = '';
                    }
                    const questionItem = document.querySelector(`[data-question-id="${questionId}"]`);
                    if (answer.content && answer.content.trim()) { questionItem.classList.add('answered'); } else { questionItem.classList.remove('answered'); }
                })
                .catch(error => { console.error('åŠ è½½ç­”æ¡ˆå¤±è´¥:', error); showSaveStatus('error', 'åŠ è½½ç­”æ¡ˆå¤±è´¥: ' + error.message); });
        }

        document.getElementById('answer-editor').addEventListener('input', function() {
            if (currentQuestionId || currentQuestionTitle) {
                if (saveTimeout) { clearTimeout(saveTimeout); }
                showSaveStatus('saving', 'æ­£åœ¨ä¿å­˜...');
                saveTimeout = setTimeout(() => { saveAnswer(); }, 2000);
            }
        });

        function toDataURL(blob) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob); }); }

        async function normalizeImages() {
            const editor = document.getElementById('answer-editor');
            const imgs = editor.querySelectorAll('img');
            const tasks = Array.from(imgs).map(async img => {
                const s = img.getAttribute('src') || '';
                if (s.startsWith('blob:')) {
                    try { const r = await fetch(s); const b = await r.blob(); const data = await toDataURL(b); img.setAttribute('src', data); } catch (e) {}
                }
            });
            await Promise.all(tasks);
        }

        async function saveAnswer() {
            if (!currentQuestionId && !currentQuestionTitle) { console.warn('æ²¡æœ‰é€‰æ‹©é¢˜ç›®ï¼Œæ— æ³•ä¿å­˜ç­”æ¡ˆ'); return; }
            await normalizeImages();
            const content = document.getElementById('answer-editor').innerHTML;
            if (!content || content.trim() === '' || content === '<br>' || content === '<div><br></div>') { console.log('ç­”æ¡ˆå†…å®¹ä¸ºç©ºï¼Œè·³è¿‡ä¿å­˜'); return; }
            const formData = new FormData();
            if (currentQuestionId) formData.append('questionId', currentQuestionId);
            if (currentQuestionTitle) formData.append('questionTitle', currentQuestionTitle);
            formData.append('content', content);
            formData.append('username', currentUsername);
            fetch('/quiz/save', { method: 'POST', body: formData })
                .then(response => { if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response.text(); })
                .then(result => { if (result.includes('æˆåŠŸ')) { showSaveStatus('success', result); const questionItem = document.querySelector(`[data-question-id="${currentQuestionId}"]`); questionItem.classList.add('answered'); } else { showSaveStatus('error', 'ä¿å­˜å¤±è´¥: ' + result); } })
                .catch(error => { console.error('ä¿å­˜å¤±è´¥:', error); showSaveStatus('error', 'ä¿å­˜å¤±è´¥: ' + error.message); });
        }

        function showSaveStatus(type, message) { const statusElement = document.getElementById('save-status'); statusElement.className = `save-status ${type}`; statusElement.textContent = message; statusElement.style.display = 'block'; setTimeout(() => { statusElement.style.display = 'none'; }, 3000); }
        function formatText(command) { document.execCommand(command, false, null); document.getElementById('answer-editor').focus(); }
        function insertImage() { document.getElementById('imageInput').click(); }
        function handleImageUpload(event) {
            const file = event.target.files[0]; if (!file) return; if (!file.type.startsWith('image/')) { alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼'); return; }
            const maxSize = 5 * 1024 * 1024; if (file.size > maxSize) { alert('å›¾ç‰‡æ–‡ä»¶è¿‡å¤§ï¼è¯·é€‰æ‹©å°äº5MBçš„å›¾ç‰‡ã€‚'); return; }
            showSaveStatus('saving', 'æ­£åœ¨ä¸Šä¼ å›¾ç‰‡...'); const reader = new FileReader(); reader.onload = function(e) {
                const base64Image = e.target.result; const img = document.createElement('img'); img.src = base64Image; img.style.maxWidth = '100%'; img.style.height = 'auto'; img.style.margin = '10px 0';
                const editor = document.getElementById('answer-editor'); editor.focus(); const selection = window.getSelection(); if (selection.rangeCount > 0) { const range = selection.getRangeAt(0); range.deleteContents(); range.insertNode(img); const br = document.createElement('br'); range.collapse(false); range.insertNode(br); range.setStartAfter(br); range.collapse(true); selection.removeAllRanges(); selection.addRange(range); } else { editor.appendChild(img); editor.appendChild(document.createElement('br')); }
                showSaveStatus('success', 'å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼'); editor.dispatchEvent(new Event('input', { bubbles: true })); };
            reader.onerror = function() { showSaveStatus('error', 'è¯»å–å›¾ç‰‡æ–‡ä»¶å¤±è´¥ï¼'); };
            reader.readAsDataURL(file); event.target.value = '';
        }

        document.addEventListener('DOMContentLoaded', function() {
            const editor = document.getElementById('answer-editor');
            editor.addEventListener('focus', function() { if (this.innerHTML === '') { this.innerHTML = ''; } });
            editor.addEventListener('blur', function() { if (this.innerHTML === '') { this.innerHTML = ''; } });
            editor.addEventListener('paste', function(e) {
                const items = e.clipboardData && e.clipboardData.items ? e.clipboardData.items : []; let handled = false;
                for (let i = 0; i < items.length; i++) { const it = items[i]; if (it.type && it.type.startsWith('image/')) { e.preventDefault(); const file = it.getAsFile(); const reader = new FileReader(); reader.onload = function(ev) { const img = document.createElement('img'); img.src = ev.target.result; img.style.maxWidth = '100%'; img.style.height = 'auto'; img.style.margin = '10px 0'; editor.focus(); const sel = window.getSelection(); if (sel.rangeCount > 0) { const range = sel.getRangeAt(0); range.deleteContents(); range.insertNode(img); } else { editor.appendChild(img); } editor.dispatchEvent(new Event('input', { bubbles: true })); }; reader.readAsDataURL(file); handled = true; } }
                if (!handled) {}
            });
            editor.addEventListener('dragover', function(e) { e.preventDefault(); });
            editor.addEventListener('drop', function(e) { e.preventDefault(); const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : []; for (let i = 0; i < files.length; i++) { const file = files[i]; if (file.type && file.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = function(ev) { const img = document.createElement('img'); img.src = ev.target.result; img.style.maxWidth = '100%'; img.style.height = 'auto'; img.style.margin = '10px 0'; editor.appendChild(img); editor.dispatchEvent(new Event('input', { bubbles: true })); }; reader.readAsDataURL(file); } } });
            loadUserStats();
        });

        function loadUserStats() { fetch(`/quiz/stats/${currentUsername}`).then(response => { if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response.text(); }).then(stats => { showSaveStatus('success', stats); }).catch(error => { console.error('åŠ è½½ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', error); }); }
    </script>
</body>
</html>
